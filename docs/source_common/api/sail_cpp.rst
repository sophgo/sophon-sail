SAIL C++ API
============

Basic function
______________

**1). get_available_tpu_num**
    .. code-block:: c

       /** @brief Get the number of available Tensor Computing Processors.
        *
        *  @return Number of available Tensor Computing Processors.
        */
       int get_available_tpu_num();

**2). set_print_flag**
    .. code-block:: c

        /** @brief Print main process time use.
         *
         *  @param print_flag.
         */
        int set_print_flag(bool print_flag);

**3). set_dump_io_flag**
    .. code-block:: c

        /** @brief Dump input date and output date.
         *
         *  @param dump_io_flag. 
         */
        int set_dump_io_flag(bool dump_io_flag);

**4). get_sail_version**
    .. code-block:: c

        /** @brief Get SOPHON-SAIL version.
         *
         *  @param sail_version. 
         */
        void get_sail_version(char* sail_version);


**5). set_decoder_env**
    .. code-block:: c

        /**
         * @brief Set Decoder environment, must set befor Decoder Constructor, else use default values
         * @param env_name refcounted_frames,extra_frame_buffer_num,rtsp_transport,stimeout,
         * rtsp_flags, buffer_size, max_delay, probesize, analyzeduration.
         */
        int set_decoder_env(std::string env_name, std::string env_value);

**6). base64_enc**
    .. code-block:: c

        /**
         * @brief Base64 encode the data to generate the corresponding base64 encoded string.
         * @param handle The handle of the device.
         * @param data The pointer to the data to be encoded.
         * @param dlen The byte length of the data to be encoded.
         * @param encoded The string generated by base64 encoding.
         * @return Return 0 on successful base64 encoding, otherwise return -1.
         */
        int base64_enc(Handle& handle, const void *data, uint32_t dlen, std::string& encoded);

**7). get_tpu_util**
    .. code-block:: c

        /**
        * @brief Get the processor percent utilization of the specified device
        *
        * @param dev_id Device id
        * @return The processor percent utilization of the specified device
        */
        int get_tpu_util(int dev_id);

**8). get_vpu_util**
    .. code-block:: c

        /**
        * @brief Get the VPU percent utilization of the specified device
        *
        * @param dev_id Device id
        * @return The VPU percent utilization of the specified device
        */
        std::vector<int> get_vpu_util(int dev_id);

**9). get_vpu_util**
    .. code-block:: c

        /**
        * @brief Get the VPP percent utilization of the specified device
        *
        * @param dev_id Device id
        * @return The VPP percent utilization of the specified device
        */
        std::vector<int> get_vpu_util(int dev_id);

**10). base64_dec**
    .. code-block:: c

        /**
         * @brief Base64 encode the data to generate the corresponding base64 encoded string.
         * @param handle The handle of the device.
         * @param data The pointer to the data to be decoded.
         * @param dlen The byte length of the data to be decoded.
         * @param p_outbuf Pointer to the decoded data.
         * @param p_size Length of the pointer to the decoded data.
         * @return Return 0 on successful base64 encoding, otherwise return -1.
         */
        int base64_dec(Handle& handle, const void *data, uint32_t dlen, uint8_t* p_outbuf, uint32_t *p_size);

**11). get_board_temp**
    .. code-block:: c

        /**
        * @brief Get the board temperature of the specified device
        *
        * @param dev_id Device id
        * @return The board temperature of the specified device
        */
        int get_board_temp(int dev_id);

**12). get_chip_temp**
    .. code-block:: c

        /**
        * @brief Get the processor temperature of the specified device
        *
        * @param dev_id Device id
        * @return The processor temperature of the specified device
        */
        int get_chip_temp(int dev_id);

**13). get_dev_stat**
    .. code-block:: c

        /**
        * @brief Get the state of the specified device
        *
        * @param dev_id Device id
        * @return The state [mem_total,mem_used,tpu_util] used of the specified device
        */
        std::vector<int> get_dev_stat(int dev_id); 



Data type
_________

**1). bm_data_type_t**
    .. code-block:: c

       enum bm_data_type_t {
         BM_FLOAT32,     // float32
         BM_FLOAT16,     // not supported for now
         BM_INT8,        // int8
         BM_UINT8        // unsigned int8
       };

PaddingAtrr
____________

**1). PaddingAtrr**
    .. code-block:: c
    
       class PaddingAtrr {
       public:
           PaddingAtrr(){};
           PaddingAtrr(
                unsigned int crop_start_x,
                unsigned int crop_start_y,
                unsigned int crop_width,
                unsigned int crop_height,
                unsigned char padding_value_r,
                unsigned char padding_value_g,
                unsigned char padding_value_b);
           PaddingAtrr(const PaddingAtrr& other);
           ~PaddingAtrr(){};
           void set_stx(unsigned int stx);
           void set_sty(unsigned int sty);
           void set_w(unsigned int w);
           void set_h(unsigned int h);
           void set_r(unsigned int r);
           void set_g(unsigned int g);
           void set_b(unsigned int b);

           unsigned int    dst_crop_stx; // Offset x information relative to the origin of dst image
           unsigned int    dst_crop_sty; // Offset y information relative to the origin of dst image
           unsigned int    dst_crop_w;   // The width after resize
           unsigned int    dst_crop_h;   // The height after resize
           unsigned char   padding_r;    // Pixel value information of R channel
           unsigned char   padding_g;    // Pixel value information of G channel
           unsigned char   padding_b;    // Pixel value information of B channel
       };

Handle
______

**1). Handle Constructor**
    .. code-block:: c

       /**
        * @brief Constructor using existed bm_handle_t.
        *
        * @param handle A bm_handle_t
        */
       Handle(bm_handle_t handle);

       /**
        * @brief Constructor with device id.
        *
        * @param dev_id Device id
        */
       Handle(int dev_id);

**2). data**
    .. code-block:: c

       /**
        *  @brief Get inner bm_handle_t.
        *
        *  @return Inner bm_handle_t
        */
       bm_handle_t data();

**3). get_device_id**
    .. code-block:: c

        /**
        * @brief Get device id of this handle.
        *
        * @return Device id.
        */
        int get_device_id();

**4). get_sn**
    .. code-block:: c
        
        /**
        * @brief Get serial number
        * 
        * @return serial number
        */
        std::string get_sn();

**4). get_target**
    .. code-block:: c
        
        /**
        * @brief Get Tensor Computing Processor type
        * 
        * @return Tensor Computing Processor type
        */
        std::string get_target();

Tensor
______

**1). Tensor Constructor**
    .. code-block:: c

       /**
        * @brief Common constructor.
        * @detail
        *  case 0: only allocate system memory
        *          (handle, shape, dtype, true, false)
        *  case 1: only allocate device memory
        *          (handle, shape, dtype, false, true)
        *  case 2: allocate system memory and device memory
        *          (handle, shape, dtype, true, true)
        *
        * @param handle       Handle instance
        * @param shape        Shape of the tensor
        * @param own_sys_data Indicator of whether own system memory.
        * @param own_dev_data Indicator of whether own device memory.
        */
       explicit Tensor(
           Handle                  handle,
           const std::vector<int>& shape,
           bm_data_type_t          dtype,
           bool                    own_sys_data,
           bool                    own_dev_data);

       /**
        *  @brief Copy constructor.
        *
        *  @param tensor A Tensor instance
        */
       Tensor(const Tensor& tensor);

**2). Tensor Assign Function**
    .. code-block:: c

       /**
        * @brief Assignment function.
        *
        * @param tensor A Tensor instance
        * @return A Tensor instance
        */
       Tensor& operator=(const Tensor& tensor);

**3). shape**
    .. code-block:: c

       /**
        * @brief Get shape of the tensor.
        *
        * @return Shape of the tensor
        */
       const std::vector<int>& shape() const;

**4). dtype**
    .. code-block:: c

       /**
        * @brief Get data type of the tensor.
        *
        * @return Data type of the tensor
        */
       void dtype();

**5). reshape**
    .. code-block:: c

       /**
        * @brief Reset shape of the tensor.
        *
        * @param shape Shape of the tensor
        */
       void reshape(const std::vector<int>& shape);

**6). own_sys_data**
    .. code-block:: c

       /**
        * @brief Judge if the tensor owns data in system memory.
        *
        * @return True for owns data in system memory.
        */
       bool own_sys_data();

**7). own_dev_data**
    .. code-block:: c

       /**
        * @brief Judge if the tensor owns data in device memory.
        *
        * @return True for owns data in device memory.
        */
       bool own_dev_data();

**8). sys_data**
    .. code-block:: c

       /**
        * @brief Get data pointer in system memory of the tensor.
        *
        * @return Data pointer in system memory of the tensor
        */
       void* sys_data();

**9). dev_data**
    .. code-block:: c

       /**
        * @brief Get pointer to device memory of the tensor.
        *
        * @return Pointer to device memory of the tensor
        */
       bm_device_mem_t* dev_data();

**10). reset_sys_data**
    .. code-block:: c

       /**
        * @brief Reset data pointer in system memory of the tensor.
        *
        * @param data  Data pointer in system memory of the tensor
        * @param shape Shape of the data
        */
       void reset_sys_data(
           void*              data,
           std::vector<int>& shape);

**11). reset_dev_data**
    .. code-block:: c

       /**
        * @brief Reset pointer to device memory of the tensor.
        *
        * @param data Pointer to device memory
        */
       void reset_dev_data(bm_device_mem_t* data);

**12). sync_s2d**
    .. code-block:: c

       /**
        * @brief Copy data from system memory to device memory.
        */
       void sync_s2d();

       /**
        * @brief Copy data from system memory to device memory with specified size.
        *
        * @param size Byte size to be copied
        */
       void sync_s2d(int size);

**13). sync_d2s**
    .. code-block:: c

       /**
        * @brief Copy data from device memory to system memory.
        */
       void sync_d2s();

       /**
        * @brief Copy data from device memory to system memory with specified size.
        *
        * @param size Byte size to be copied
        */
       void sync_d2s(int size);

**14). free**
    .. code-block:: c

       /**
        * @brief Free system and device memroy of the tensor.
        */
       void free();

**15). dump_data**
    .. code-block:: c

       /**
        * @brief Dump Tensor data to file.
        */
       void dump_data(std::string file_name, bool bin = false);

IOMode
______

**1). IOMode**
    .. code-block:: c

        enum IOMode {
          /// Input tensors are in system memory while output tensors are
          /// in device memory.
          SYSI,
          /// Input tensors are in device memory while output tensors are
          /// in system memory.
          SYSO,
          /// Both input and output tensors are in system memory.
          SYSIO,
          /// Both input and output tensors are in device memory.
          DEVIO
        };

Engine
______

**1). Engine Constructor**
    .. code-block:: c

       /**
        * @brief Constructor does not load bmodel.
        *
        * @param tpu_id Tensor Computing Processor ID. You can use bm-smi to see available IDs.
        */
        Engine(int tpu_id);

       /**
        * @brief Constructor does not load bmodel.
        *
        * @param handle Handle created elsewhere.
        */
       Engine(const Handle&   handle);

       /**
        * @brief Constructor loads bmodel from file.
        *
        * @param bmodel_path Path to bmodel
        * @param tpu_id      Tensor Computing Processor ID. You can use bm-smi to see available IDs.
        * @param mode        Specify the input/output tensors are in system memory
        *                   or device memory
        */
       Engine(
           const std::string& bmodel_path,
           int                tpu_id,
           IOMode             mode);

       /**
        * @brief Constructor loads bmodel from file.
        *
        * @param bmodel_path Path to bmodel
        * @param handle      Handle created elsewhere.
        * @param mode        Specify the input/output tensors are in system memory
        *                    or device memory
        */
       Engine(
           const std::string& bmodel_path,
           const Handle&      handle,
           IOMode             mode);

       /**
        * @brief Constructor loads bmodel from system memory.
        *
        * @param bmodel_ptr  Pointer to bmodel in system memory
        * @param bmodel_size Byte size of bmodel in system memory
        * @param tpu_id      Tensor Computing Processor ID. You can use bm-smi to see available IDs.
        * @param mode        Specify the input/output tensors are in system memory
        *                   or device memory
        */
        Engine(
            const void* bmodel_ptr,
            size_t      bmodel_size,
            int         tpu_id,
            IOMode      mode);

       /**
        * @brief Constructor loads bmodel from system memory.
        *
        * @param bmodel_ptr  Pointer to bmodel in system memory
        * @param bmodel_size Byte size of bmodel in system memory
        * @param handle      Handle created elsewhere.
        * @param mode        Specify the input/output tensors are in system memory
        *                    or device memory
        */
       Engine(
           const void*        bmodel_ptr,
           size_t             bmodel_size,
           const Handle&      handle,
           IOMode             mode);

       /**
        * @brief Copy constructor.
        *
        * @param other An other Engine instance.
        */
       Engine(const Engine& other);

**2). Engine Assign Function**
    .. code-block:: c

       /**
        * @brief Assignment function.
        *
        * @param other An other Engine instance.
        * @return Reference of a Engine instance.
        */
       Engine<Dtype>& operator=(const Engine& other);

**3). get_handle**
    .. code-block:: c

       /**
        * @brief Get Handle instance.
        *
        * @return Handle instance
        */
       Handle get_handle();

**4). load**
    .. code-block:: c

       /**
        * @brief Load bmodel from file.
        *
        * @param bmodel_path Path to bmodel
        * @return Program state
        *     @retval true  Success
        *     @retval false Failure
        */
       bool load(const std::string& bmodel_path);

       /**
        * @brief Load bmodel from system memory.
        *
        * @param bmodel_ptr  Pointer to bmodel in system memory
        * @param bmodel_size Byte size of bmodel in system memory
        * @return Program state
        *     @retval true  Success
        *    @retval false Failure
        */
       bool load(const void* bmodel_ptr, size_t bmodel_size);

**5). get_graph_names**
    .. code-block:: c

       /**
        * @brief Get all graph names in the loaded bomodels.
        *
        * @return All graph names
        */
       std::vector<std::string> get_graph_names();

**6). set_io_mode**
    .. code-block:: c

       /**
        * @brief Set IOMode for a graph.
        *
        * @param graph_name The specified graph name
        * @param mode The specified IOMode
        */
       void set_io_mode(
         const std::string& graph_name,
         IOMode             mode);

**7). get_input_names**
    .. code-block:: c

       /**
        * @brief Get all input tensor names of the specified graph.
        *
        * @param graph_name The specified graph name
        * @return All the input tensor names of the graph
        */
       std::vector<std::string> get_input_names(const std::string& graph_name);

**8). get_output_names**
    .. code-block:: c

       /**
        * @brief Get all output tensor names of the specified graph.
        *
        * @param graph_name The specified graph name
        * @return All the output tensor names of the graph
        */
       std::vector<std::string> get_output_names(const std::string& graph_name);

**9). get_max_input_shapes**
    .. code-block:: c

       /**
        * @brief Get max shapes of input tensors in a graph.
        *
        * For static models, the max shape is fixed and it should not be changed.
        * For dynamic models, the tensor shape should be smaller than or equal to
        * the max shape.
        *
        * @param graph_name The specified graph name
        * @return Max shape of input tensors
        */
       std::map<std::string, std::vector<int>> get_max_input_shapes(
           const std::string& graph_name);

**10). get_input_shape**
    .. code-block:: c

       /**
        * @brief Get the shape of an input tensor in a graph.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return The shape of the tensor
        */
       std::vector<int> get_input_shape(
           const std::string& graph_name,
           const std::string& tensor_name);

**11). get_max_output_shapes**
    .. code-block:: c

       /**
        * @brief Get max shapes of output tensors in a graph.
        *
        * For static models, the max shape is fixed and it should not be changed.
        * For dynamic models, the tensor shape should be smaller than or equal to
        * the max shape.
        *
        * @param graph_name The specified graph name
        * @return Max shape of output tensors
        */
       std::map<std::string, std::vector<int>> get_max_output_shapes(
           const std::string& graph_name);

**12). get_output_shape**
    .. code-block:: c

       /**
        * @brief Get the shape of an output tensor in a graph.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return The shape of the tensor
        */
       std::vector<int> get_output_shape(
           const std::string& graph_name,
           const std::string& tensor_name);

**13). get_input_dtype**
    .. code-block:: c

       /**
        * @brief Get data type of an input tensor. Refer to bmdef.h as following.
        *   typedef enum {
        *     BM_FLOAT32 = 0,
        *     BM_FLOAT16 = 1,
        *     BM_INT8 = 2,
        *     BM_UINT8 = 3,
        *     BM_INT16 = 4,
        *     BM_UINT16 = 5,
        *     BM_INT32 = 6,
        *     BM_UINT32 = 7
        *   } bm_data_type_t;
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return Data type of the input tensor
        */
       bm_data_type_t get_input_dtype(
           const std::string& graph_name,
           const std::string& tensor_name);

**14). get_output_dtype**
    .. code-block:: c

       /**
        * @brief Get data type of an output tensor. Refer to bmdef.h as following.
        *   typedef enum {
        *     BM_FLOAT32 = 0,
        *     BM_FLOAT16 = 1,
        *     BM_INT8 = 2,
        *     BM_UINT8 = 3,
        *     BM_INT16 = 4,
        *     BM_UINT16 = 5,
        *     BM_INT32 = 6,
        *     BM_UINT32 = 7
        *   } bm_data_type_t;
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return Data type of the input tensor
        */
       bm_data_type_t get_output_dtype(
           const std::string& graph_name,
           const std::string& tensor_name);

**15). get_input_scale**
    .. code-block:: c

       /**
        * @brief Get scale of an input tensor. Only used for int8 models.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return Scale of the input tensor
        */
       float get_input_scale(
           const std::string& graph_name,
           const std::string& tensor_name);

**16). get_output_scale**
    .. code-block:: c

       /**
        * @brief Get scale of an output tensor. Only used for int8 models.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return Scale of the output tensor
        */
       float get_output_scale(
           const std::string& graph_name,
           const std::string& tensor_name);

**17). reshape**
    .. code-block:: c

       /**
        * @brief Reshape input tensor for dynamic models.
        *
        * The input tensor shapes may change when running dynamic models.
        * New input shapes should be set before inference.
        *
        * @param graph_name   The specified graph name
        * @param input_shapes Specified shapes of all input tensors of the graph
        * @return 0 for success and 1 for failure
        */
       int reshape(
           const std::string&                       graph_name,
           std::map<std::string, std::vector<int>>& input_shapes);

**18). get_input_tensor**
    .. code-block:: c

       /**
        * @brief Get the specified input tensor.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return The specified input tensor
        */
       Tensor* get_input_tensor(
           const std::string& graph_name,
           const std::string& tensor_name);

**19). get_output_tensor**
    .. code-block:: c

       /**
        * @brief Get the specified output tensor.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @return The specified output tensor
        */
       Tensor* get_output_tensor(
           const std::string& graph_name,
           const std::string& tensor_name);

**20). scale_input_tensor**
    .. code-block:: c

       /**
        * @brief Scale input tensor for int8 models.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @param data        Pointer to float data to be scaled
        */
       void scale_input_tensor(
           const std::string& graph_name,
           const std::string& tensor_name,
           float*             data);

**21). scale_output_tensor**
    .. code-block:: c

       /**
        * @brief Scale output tensor for int8 models.
        *
        * @param graph_name  The specified graph name
        * @param tensor_name The specified tensor name
        * @param data        Pointer to float data to be scaled
        */
       void scale_output_tensor(
           const std::string& graph_name,
           const std::string& tensor_name,
           float*             data);


**22). scale_fp32_to_int8**
    .. code-block:: c

       /**
        * @brief Scale data from float32 to int8. Only used for int8 models.
        *
        * @param src   Poniter to float32 data
        * @param dst   Poniter to int8 data
        * @param scale Value of scale
        * @param size  Size of data
        */
       void scale_fp32_to_int8(float* src, int8_t* dst, float scale, int size);

**23). scale_int8_to_fp32**
    .. code-block:: c

       /**
        * @brief Scale data from int8 to float32. Only used for int8 models.
        *
        * @param src   Poniter to int8 data
        * @param dst   Poniter to float32 data
        * @param scale Value of scale
        * @param size  Size of data
        */
       void scale_int8_to_fp32(int8_t* src, float* dst, float scale, int size);

**24). process**
    .. code-block:: c

       /**
        * @brief Inference with builtin input and output tensors.
        *
        * @param graph_name The specified graph name
        */
       void process(const std::string& graph_name);

       /**
        * @brief Inference with provided input tensors.
        *
        * @param graph_name    The specified graph name
        * @param input_shapes  Shapes of all input tensors
        * @param input_tensors Data pointers of all input tensors in system memory
        */
       void process(
           const std::string&                       graph_name,
           std::map<std::string, std::vector<int>>& input_shapes,
           std::map<std::string, void*>&            input_tensors);

       /**
        * @brief Inference with provided input and output tensors.
        *
        * @param graph_name The specified graph name
        * @param input      Input tensors
        * @param output     Output tensors
        */
       void process(
           const std::string&              graph_name,
           std::map<std::string, Tensor*>& input,
           std::map<std::string, Tensor*>& output);

       /**
        * @brief Inference with provided input and output tensors and input shapes.
        *
        * @param graph_name   The specified graph name
        * @param input        Input tensors
        * @param input_shapes Real input tensor shapes
        * @param output       Output tensors
        */
       void process(
           const std::string&                       graph_name,
           std::map<std::string, Tensor*>&          input,
           std::map<std::string, std::vector<int>>& input_shapes,
           std::map<std::string, Tensor*>&          output);


**25). create_input_tensors_map**
    .. code-block:: c

       /**
        * @brief Create input tensors map, according to and bmodel.
        * @param graph_name   The specified graph name
        * @param create_mode Tensor Create mode
        *  case 0: only allocate system memory 
        *  case 1: only allocate device memory
        *  case other: according to engine IOMode
        */
        std::map<std::string, Tensor*> create_input_tensors_map(
            const std::string& graph_name, 
            int create_mode = -1);
  

**26). create_output_tensors_map**
    .. code-block:: c

       /**
        * @brief Create output tensors map, according to and bmodel.
        * @param graph_name   The specified graph name 
        * @param create_mode Tensor Create mode 
        *  case 0: only allocate system memory
        *  case 1: only allocate device memory
        *  case other: according to engine IOMode
        */
        std::map<std::string, Tensor*> create_output_tensors_map(
            const std::string& graph_name, 
            int create_mode = -1);
  
BMImage
_______

**1). BMImage Constructor**
    .. code-block:: c

       /**
        * @brief The default Constructor.
        */
       BMImage();

       /**
        * @brief The BMImage Constructor.
        *
        * @param handle A Handle instance
        * @param h      Image width
        * @param w      Image height
        * @param format Image format
        * @param dtype  Data type
        */
       BMImage(
           Handle&                  handle,
           int                      h,
           int                      w,
           bm_image_format_ext      format,
           bm_image_data_format_ext dtype);

**2). data**
    .. code-block:: c

       /**
        * @brief Get inner bm_image
        *
        * @return The inner bm_image
        */
       bm_image& data();

**3). width**
    .. code-block:: c

       /**
        * @brief Get the img width.
        *
        * @return the width of img
        */
       int width();

**4). height**
    .. code-block:: c

       /**
        * @brief Get the img height.
        *
        * @return the height of img
        */
       int height();

**5). format**
    .. code-block:: c

       /**
        * @brief Get the img format.
        *
        * @return the format of img
        */
       bm_image_format_ext format();


**6). data**
    .. code-block:: c

        /**
        * @brief Get inner bm_image
        *
        * @return The inner bm_image
        */
        bm_image& data();

**7). get_device_id**
    .. code-block:: c
        
        /**
        * @brief Get device id of this image.
        *
        * @return Device id.
        */
        int get_device_id() const;
        
**8). align**

    .. code-block:: c

         /**
        * @brief Align the bm_image to 64 bytes.
        *
        * @return ret.
        */
        int align();

**9). check_align**

    .. code-block:: c

        /**
        * @brief Check if the bm_image aligned.
        *
        * @return ret.
        */
        bool check_align()const;

**10). unalign**

    .. code-block:: c

        /**
        * @brief Unalign the bm_image to source bm_image.
        *
        * @return ret.
        */
        bool unalign();

**11). check_contiguous_memory**

    .. code-block:: c

        /**
        * @brief Check if the bm_image's memory contiguous.
        *
        * @return ret.
        */
        bool check_contiguous_memory()const;

**12). get_handle**

    .. code-block:: c

        /**
        * @brief Get Handle of this BMImage.
        *
        * @return Handle.
        */
        Handle& get_handle();

Decoder
_______

**1). Decoder Constructor**
    .. code-block:: c

       /**
        * @brief Constructor.
        *
        * @param file_path  Path or rtsp url to the video/image file.
        * @param compressed Whether the format of decoded output is compressed NV12.
        * @param tpu_id     ID of Tensor Computing Processor, there may be more than one Tensor Computing Processor for PCIE mode.
        */
       Decoder(
           const std::string& file_path,
           bool               compressed = true,
           int                tpu_id = 0);

**2). is_opened**
    .. code-block:: c

       /**
        * @brief Judge if the source is opened successfully.
        *
        * @return True if the source is opened successfully
        */
       bool is_opened();

**3). read**
    .. code-block:: c

       /**
        * @brief Read a bm_image from the Decoder.
        *
        * @param handle A bm_handle_t instance
        * @param image Reference of bm_image to be read to
        * @return 0 for success and 1 for failure
        */
       int read(Handle& handle, bm_image& image);

       /**
        * @brief Read a BMImage from the Decoder.
        *
        * @param handle A bm_handle_t instance
        * @param image Reference of BMImage to be read to
        * @return 0 for success and 1 for failure
        */
       int read(Handle& handle, BMImage& image);
    
**4). enable_dump**
    .. code-block:: c

       /**
        * @brief enable input video dump without encode.
        */
       void enable_dump();

**5). disable_dump**
    .. code-block:: c

       /**
        * @brief disable input video dump without encode.
        */
       void disable_dump();

**6). dump**
    .. code-block:: c

        /**
        * @brief video dump 
        * do not need to encode, just dump AVPacket(s) when decode
        * 
        * |---gop----|---gop----|---gop----|---gop----|
        * IPPPPPPPPPPIPPPPPPPPPPIPPPPPPPPPPIPPPPPPPPPPI
        *                  ^
        *                  (dump the stream before and after the current frame)
        * At the time of calling this function, dump the input video for several seconds before and after. Due to the lack of encoding, it is necessary to dump the keyframes that all frames depend on within a few seconds before and after. Therefore, the dump implementation of the interface is based on gop, and the actual video duration under dump will be higher than the input parameter duration. The error depends on the gop of the input video. The larger the size and gop, the larger the error.
        * @param dump_pre_seconds dump video length(seconds) before dump moment
        * @param dump_post_seconds dump video length(seconds) after dump moment
        * @param  file_path output path
        * @return 0 for success and -1 for failure
        */
        int dump(int dump_pre_seconds, int dump_post_seconds, std::string& file_path);

**7). get_pts_dts**
    .. code-block:: c

       /**
        * @brief get pts and dts.
        * @return the value of pts and dts.
        */
       vector<double> get_pts_dts();
       
Bmcv
_____

**1). Bmcv Constructor**
    .. code-block:: c

       /**
        * @brief Constructor.
        *
        * @param handle A Handle instance
        */
       explicit Bmcv(Handle handle);

**2). bm_image_to_tensor**
    .. code-block:: c

       /**
        * @brief Convert BMImage to tensor.
        *
        * @param img    Input image
        * @param tensor Output tensor
        */
       void bm_image_to_tensor(BMImage &img, Tensor &tensor);

       /**
        * @brief Convert BMImage to tensor.
        *
        * @param img Input image
        */
       Tensor bm_image_to_tensor(BMImage &img);

**3). tensor_to_bm_image**
    .. code-block:: c

       /**
        * @brief Convert tensor to BMImage.
        *
        * @param tensor   Input tensor
        * @param img      Output image
        * @param bgr2rgb  Swap color channel
        * @param layout   Layout of the input tensoor
        */
       void tensor_to_bm_image(Tensor &tensor, BMImage &img, bool bgr2rgb=false, std::string layout = std::string("nchw"));

       /**
        * @brief Convert tensor to BMImage.
        *
        * @param tensor   Input tensor
        * @param img      Output image
        * @param format  Format of the BMImage
        */
       void tensor_to_bm_image(Tensor &tensor, BMImage &img, bm_image_format_ext format);

       /**
        * @brief Convert tensor to BMImage.
        *
        * @param tensor   Input tensor
        * @param bgr2rgb  Swap color channel
        * @param layout   Layout of the input tensoor
        */
       BMImage tensor_to_bm_image(Tensor &tensor, bool bgr2rgb=false, std::string layout = std::string("nchw"));

       /**
        * @brief Convert tensor to BMImage.
        *
        * @param tensor   Input tensor
        * @param format  Format of the BMImage
        */
       BMImage tensor_to_bm_image (Tensor &tensor, bm_image_format_ext format);

**4). crop_and_resize**
    .. code-block:: c

       /**
        * @brief Crop then resize an image.
        *
        * @param input    Input image
        * @param output   Output image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
       int crop_and_resize(
           BMImage                      &input,
           BMImage                      &output,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h,
           int                          resize_w,
           int                          resize_h,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Crop then resize an image.
        *
        * @param input    Input image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
       BMImage crop_and_resize(
           BMImage                      &input,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h,
           int                          resize_w,
           int                          resize_h,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**5). crop**
    .. code-block:: c

       /**
        * @brief Crop an image with given window.
        *
        * @param input    Input image
        * @param output   Output image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @return 0 for success and other for failure
        */
       int crop(
           BMImage                      &input,
           BMImage                      &output,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h);

       /**
        * @brief Crop an image with given window.
        *
        * @param input    Input image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @return Output image
        */
        BMImage crop(
           BMImage                      &input,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h);

**6). resize**
    .. code-block:: c

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST.
        *
        * @param input    Input image
        * @param output   Output image
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
       int resize(
           BMImage                      &input,
           BMImage                      &output,
           int                          resize_w,
           int                          resize_h,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST.
        *
        * @param input    Input image
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
       BMImage resize(
           BMImage                      &input,
           int                          resize_w,
           int                          resize_h,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**7). vpp_crop_and_resize**
    .. code-block:: c

       /**
        * @brief Crop then resize an image using vpp.
        *
        * @param input    Input image
        * @param output   Output image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
        int vpp_crop_and_resize(
            BMImage                      &input,
            BMImage                      &output,
            int                          crop_x0,
            int                          crop_y0,
            int                          crop_w,
            int                          crop_h,
            int                          resize_w,
            int                          resize_h,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Crop then resize an image using vpp.
        *
        * @param input    Input image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
        BMImage vpp_crop_and_resize(
            BMImage                      &input,
            int                          crop_x0,
            int                          crop_y0,
            int                          crop_w,
            int                          crop_h,
            int                          resize_w,
            int                          resize_h,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**8). vpp_crop_and_resize_padding**
    .. code-block:: c

       /**
        * @brief Crop then resize an image using vpp.
        *
        * @param input       Input image
        * @param output      Output image
        * @param crop_x0     Start point x of the crop window
        * @param crop_y0     Start point y of the crop window
        * @param crop_w      Width of the crop window
        * @param crop_h      Height of the crop window
        * @param resize_w    Target width
        * @param resize_h    Target height
        * @param padding_in  PaddingAtrr info
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
        int vpp_crop_and_resize_padding(
            BMImage                      &input,
            BMImage                      &output,
            int                          crop_x0,
            int                          crop_y0,
            int                          crop_w,
            int                          crop_h,
            int                          resize_w,
            int                          resize_h,
            PaddingAtrr                  &padding_in,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Crop then resize an image using vpp.
        *
        * @param input       Input image
        * @param crop_x0     Start point x of the crop window
        * @param crop_y0     Start point y of the crop window
        * @param crop_w      Width of the crop window
        * @param crop_h      Height of the crop window
        * @param resize_w    Target width
        * @param resize_h    Target height
        * @param padding_in  PaddingAtrr info
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
        BMImage vpp_crop_and_resize_padding(
            BMImage                      &input,
            int                          crop_x0,
            int                          crop_y0,
            int                          crop_w,
            int                          crop_h,
            int                          resize_w,
            int                          resize_h,
            PaddingAtrr                  &padding_in,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**9). vpp_crop**
    .. code-block:: c

       /**
        * @brief Crop an image with given window using vpp.
        *
        * @param input    Input image
        * @param output   Output image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @return 0 for success and other for failure
        */
       int vpp_crop(
           BMImage                      &input,
           BMImage                      &output,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h);

       /**
        * @brief Crop an image with given window using vpp.
        *
        * @param input    Input image
        * @param crop_x0  Start point x of the crop window
        * @param crop_y0  Start point y of the crop window
        * @param crop_w   Width of the crop window
        * @param crop_h   Height of the crop window
        * @return Output image
        */
       BMImage vpp_crop(
           BMImage                      &input,
           int                          crop_x0,
           int                          crop_y0,
           int                          crop_w,
           int                          crop_h);

**10). vpp_resize**
    .. code-block:: c

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST using vpp.
        *
        * @param input    Input image
        * @param output   Output image
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
        int vpp_resize(
            BMImage                      &input,
            BMImage                      &output,
            int                          resize_w,
            int                          resize_h,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST using vpp.
        *
        * @param input    Input image
        * @param resize_w Target width
        * @param resize_h Target height
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
       BMImage vpp_resize(
           BMImage                      &input,
           int                          resize_w,
           int                          resize_h,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**11). vpp_resize_padding**
    .. code-block:: c

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST using vpp.
        *
        * @param input       Input image
        * @param output      Output image
        * @param resize_w    Target width
        * @param resize_h    Target height
        * @param padding_in  PaddingAtrr info
        * @param resize_alg  Resize algorithm
        * @return 0 for success and other for failure
        */
        int vpp_resize_padding(
            BMImage                      &input,
            BMImage                      &output,
            int                          resize_w,
            int                          resize_h,
            PaddingAtrr                  &padding_in,
            bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

       /**
        * @brief Resize an image with interpolation of INTER_NEAREST using vpp.
        *
        * @param input       Input image
        * @param resize_w    Target width
        * @param resize_h    Target height
        * @param padding_in  PaddingAtrr info
        * @param resize_alg  Resize algorithm
        * @return Output image
        */
       BMImage vpp_resize_padding(
           BMImage                      &input,
           int                          resize_w,
           int                          resize_h,
           PaddingAtrr                  &padding_in,
           bmcv_resize_algorithm        resize_alg = BMCV_INTER_NEAREST);

**12). warp**
    .. code-block:: c

       /**
        * @brief Applies an affine transformation to an image.
        *
        * @param input             Input image
        * @param output            Output image
        * @param matrix            2x3 transformation matrix
        * @param use_bilinear      Bilinear use flag
        * @param similar_to_opencv The interface bmcv_image_warp_affine_similar_to_opencv use flag
        * @return 0 for success and other for failure
        */
       int warp(
           BMImage                            &input,
           BMImage                            &output,
           const std::pair<
             std::tuple<float, float, float>,
             std::tuple<float, float, float>> &matrix,
           int                                use_bilinear = 0,
           bool                               similar_to_opencv = false);

       /**
        * @brief Applies an affine transformation to an image.
        *
        * @param input    Input image
        * @param matrix   2x3 transformation matrix
        * @param use_bilinear Bilinear use flag
        * @param similar_to_opencv The interface bmcv_image_warp_affine_similar_to_opencv use flag
        * @return Output image
        */
       BMImage warp(
           BMImage                            &input,
           const std::pair<
             std::tuple<float, float, float>,
             std::tuple<float, float, float>> &matrix,
           int                                use_bilinear = 0,
           bool                               similar_to_opencv = false);

**13). convert_to**
    .. code-block:: c

       /**
        * @brief Applies a linear transformation to an image.
        *
        * @param input        Input image
        * @param output       Output image
        * @param alpha_beta   (a0, b0), (a1, b1), (a2, b2) factors
        * @return 0 for success and other for failure
        */
       int convert_to(
           BMImage                      &input,
           BMImage                      &output,
           const std::tuple<
             std::pair<float, float>,
             std::pair<float, float>,
             std::pair<float, float>>   &alpha_beta);

       /**
        * @brief Applies a linear transformation to an image.
        *
        * @param input        Input image
        * @param alpha_beta   (a0, b0), (a1, b1), (a2, b2) factors
        * @return Output image
        */
       BMImage convert_to(
           BMImage                      &input,
           const std::tuple<
             std::pair<float, float>,
             std::pair<float, float>,
             std::pair<float, float>>   &alpha_beta);

**14). yuv2bgr**
    .. code-block:: c

       /**
        * @brief Convert an image from YUV to BGR.
        *
        * @param input    Input image
        * @param output   Output image
        * @return 0 for success and other for failure
        */
       int yuv2bgr(
           BMImage                      &input,
           BMImage                      &output);

       /**
        * @brief Convert an image from YUV to BGR.
        *
        * @param input    Input image
        * @return Output image
        */
       BMImage yuv2bgr(BMImage  &input);

**15). vpp_convert_format**
    .. code-block:: c

       /**
        * @brief Image format conversion.
        *
        * @param input    Input image
        * @param output   Output image
        * @return 0 for success and other for failure
        */
       int vpp_convert_format(
           BMImage  &input,
           BMImage  &output);

       /**
        * @brief Image format conversion.
        *
        * @param input    Input image
        * @param image_format    Format of the output image
        * @return Output image
        */
       BMImage vpp_convert_format(BMImage  &input, bm_image_format_ext image_format = FORMAT_BGR_PLANAR);

**16). convert_format**
    .. code-block:: c

       /**
        * @brief Image format conversion.
        *
        * @param input    Input image
        * @param output   Output image
        * @return 0 for success and other for failure
        */
       int convert_format(
           BMImage  &input,
           BMImage  &output);

       /**
        * @brief Image format conversion.
        *
        * @param input    Input image
        * @param image_format    Format of the output image
        * @return Output image
        */
       BMImage convert_format(BMImage  &input, bm_image_format_ext image_format = FORMAT_BGR_PLANAR);

**17). rectangle**
    .. code-block:: c

       /**
        * @brief Draw a rectangle on input image.
        *
        * @param image      Input image
        * @param x0         Start point x of rectangle
        * @param y0         Start point y of rectangle
        * @param w          Width of rectangle
        * @param h          Height of rectangle
        * @param color      Color of rectangle
        * @param thickness  Thickness of rectangle
        * @return 0 for success and other for failure
        */
       int rectangle(
           BMImage                         &image,
           int                             x0,
           int                             y0,
           int                             w,
           int                             h,
           const std::tuple<int, int, int> &color,
           int                             thickness=1);
        
**18). rectangle_**
    .. code-block:: c

       /**
        * @brief Draw a rectangle on input image.
        *
        * @param image      Input image
        * @param x0         Start point x of rectangle
        * @param y0         Start point y of rectangle
        * @param w          Width of rectangle
        * @param h          Height of rectangle
        * @param color      Color of rectangle
        * @param thickness  Thickness of rectangle
        * @return 0 for success and other for failure
        */
       int rectangle_(
           const bm_image                  &image,
           int                             x0,
           int                             y0,
           int                             w,
           int                             h,
           const std::tuple<int, int, int> &color, // BGR
           int                             thickness=1);

**19). imwrite**
    .. code-block:: c

       /**
        * @brief Save the image to the specified file.
        *
        * @param filename   Name of the file
        * @param image      Image to be saved
        * @return 0 for success and other for failure
        */
       int imwrite(
           const std::string &filename,
           BMImage           &image);

**20). imwrite_**
    .. code-block:: c

       /**
        * @brief Save the image to the specified file.
        *
        * @param filename   Name of the file
        * @param image      Image to be saved
        * @return 0 for success and other for failure
        */
       int imwrite_(
           const std::string &filename,
           const bm_image     &image);

**21). get_handle**
    .. code-block:: c

       /**
        * @brief Get Handle instance.
        *
        * @return Handle instance
        */
       Handle get_handle();

**22). putText**
    .. code-block:: c

       /**
        * @brief put text on input image
        * 
        * @param image     Input image
        * @param text      Text string to be drawn
        * @param x         Start x
        * @param y         Start y
        * @param color     Color of text
        * @param fontScale Font scale factor that is multiplied by the font-specific base size
        * @param thickness Thickness of the lines used to draw a text
        * @return int 
        */
       int putText(
           const BMImage                   &image,
           const std::string               &text,
           int                             x,
           int                             y,
           const std::tuple<int, int, int> &color, // BGR
           float                           fontScale,
           int                             thickness=1);

**23). putText_**
    .. code-block:: c

       /**
        * @brief put text on input image
        * 
        * @param image     Input image
        * @param text      Text string to be drawn
        * @param x         Start x
        * @param y         Start y
        * @param color     Color of text
        * @param fontScale Font scale factor that is multiplied by the font-specific base size
        * @param thickness Thickness of the lines used to draw a text
        * @return int 
        */
       int putText_(
           const bm_image                  &image,
           const std::string               &text,
           int                             x,
           int                             y,
           const std::tuple<int, int, int> &color, // BGR
           float                           fontScale,
           int                             thickness=1);

**24). image_add_weighted**
    .. code-block:: c
    
       /**
        * @brief output = input1 * alpha + input2 * beta + gamma
        */
       int image_add_weighted(
           BMImage           &input1,
           float             alpha,
           BMImage           &input2,
           float             beta,
           float             gamma,
           BMImage           &output);

       BMImage image_add_weighted(
           BMImage           &input1,
           float             alpha,
           BMImage           &input2,
           float             beta,
           float             gamma);
        
**25). image_add_weighted**
    .. code-block:: c
    
       /**
        * @brief Copy input image to output
        * @param input   Input image
        * @param output  Output image
        * @param start_x Target starting point x
        * @param start_y Target starting point y
        */
       int image_copy_to(
           bm_image input, 
           bm_image output, 
           int start_x, 
           int start_y);

       int image_copy_to(
           BMImage &input, 
           BMImage &output, 
           int start_x = 0, 
           int start_y = 0);

**26). image_add_weighted**
    .. code-block:: c
 
       /**
        * @brief Copy input image to output with padding
        * @param input   Input image
        * @param output  Output image
        * @param start_x       Target starting point x
        * @param start_y       Target starting point y
        * @param padding_r     padding value of r
        * @param padding_g     padding value of g
        * @param padding_b     padding value of b
       */
       int image_copy_to_padding(
           bm_image input, 
           bm_image output,
           unsigned int padding_r, 
           unsigned int padding_g, 
           unsigned int padding_b,
           int start_x, 
           int start_y);

       int image_copy_to_padding(
           BMImage &input, 
           BMImage &output,
           unsigned int padding_r, 
           unsigned int padding_g, 
           unsigned int padding_b,
           int start_x = 0, 
           int start_y = 0);

**27). nms**
    .. code-block:: c

       /**
        * @brief Do nms use tpu
        * 
        * @param input_proposal input proposal objects
        * @param threshold      nms threshold
        * @param proposal_size  proposal size
        * @return result boxes [for c++, result memory should free by user]
        */
    
        nms_proposal_t* nms(
            face_rect_t *input_proposal,
            int proposal_size, 
            float threshold);

**28). drawPoint**
    .. code-block:: c

        /**
        * @brief Draw point.
        * 
        * @param image         Input image
        * @param center        Center of point
        * @param color         Color of point
        * @param radius        Radius of point
        */

        int drawPoint(
            const BMImage &image,
            std::pair<int,int> center,
            std::tuple<unsigned char, unsigned char, unsigned char> color,   // BGR
            int radius);

**29). drawPoint_**
    .. code-block:: c
        
        /**
        * @brief Draw point.
        * 
        * @param image         Input image
        * @param center        Center of point
        * @param color         Color of point
        * @param radius        Radius of point
        */

        int drawPoint_(
            const bm_image &image,
            std::pair<int,int> center,
            std::tuple<unsigned char, unsigned char, unsigned char> color,   // BGR
            int radius);

**30). imdecode**
    .. code-block:: c

        /**
        * @brief Load image from system memory.
        *
        * @param data_ptr  Pointer to image in system memory
        * @param data_size Byte size of image in system memory
        * @return BMImage
        */
        BMImage imdecode(const void* data_ptr, size_t data_size);

**31). fft**
    .. code-block:: c

        /**
        * @brief fft.
        * 
        * @param forward forward or Inverse transformation
        * @param input_real The real part of input
        * @param input_imag The imaginary part of input
        * @return std::vector<Tensor> The real and imaginary part of output
        */
        std::vector<Tensor> fft(bool forward, Tensor &input_real);
        std::vector<Tensor> fft(bool forward, Tensor &input_real, Tensor &input_imag);

**32). convert_yuv420p_to_gray**
    .. code-block:: c

        /**
        * @brief Convert a BMImage in yuv420p format to a BMImage in gray format.
        * 
        * @param input BMImage in yuv420p format
        * @param output BMImage in gray format
        * @return int 
        */
        int convert_yuv420p_to_gray(BMImage& input, BMImage& output);

**33). convert_yuv420p_to_gray_**
    .. code-block:: c

        /**
        * @brief Convert a bm_image in yuv420p format to a bm_image in gray format.
        * 
        * @param input bm_image in yuv420p format
        * @param output bm_image in gray format
        * @return int 
        */
        int convert_yuv420p_to_gray_(bm_image& input, bm_image& output);

**34). imdecode**
    .. code-block:: c

        /**
        * @brief Compresses the BMImage and stores it in the memory
        *
        * @param ext       File extension that defines the output format.
        * @param img       BMImage to be written
        * @param buf       Output buffer resized to fit the compressed BMImage
        * @return bool
        */
        bool imencode(std::string& ext, BMImage &img, std::vector<u_char>& buf);

**35). stft**
    .. code-block:: c

        /**
        * @brief Compute the Short-Time Fourier Transform (STFT)
        * 
        * @param input_real  The real part of the input signal, type: pybind11::array_t<float>
        * @param input_imag  The imaginary part of the input signal, type: pybind11::array_t<float>
        * @param realInput   A flag indicating whether to use only the real input, type: bool
        * @param normalize    A flag indicating whether to normalize the output, type: bool
        * @param n_fft       The number of FFT points, type: int
        * @param hop_len     The hop length for windowing, type: int
        * @param pad_mode    The padding mode, type: int
        * @param win_mode    The window type, type: int
        * 
        * @return A tuple containing two pybind11::array_t<float>:
        *         The first element is the real part of the STFT, and the second element is the imaginary part of the STFT.
        */
        std::tuple<pybind11::array_t<float>, pybind11::array_t<float>> Bmcv::stft(
            pybind11::array_t<float> input_real,
            pybind11::array_t<float> input_imag,
            bool realInput,
            bool normalize,
            int n_fft,
            int hop_len,
            int pad_mode,
            int win_mode
        );

        std::tuple<Tensor, Tensor> Bmcv::stft(
            Tensor &input_real,
            Tensor &input_imag,
            bool realInput,
            bool normalize,
            int n_fft,
            int hop_len,
            int pad_mode,
            int win_mode
        );

**36). istft**
    .. code-block:: c

        /**
        * @brief Compute the Inverse Short-Time Fourier Transform (ISTFT)
        * 
        * This function computes the inverse STFT from the provided real and imaginary parts
        * of the frequency-domain representation, reconstructing the time-domain signal.
        * 
        * @param input_real   The real part of the STFT, type: pybind11::array_t<float>
        * @param input_imag   The imaginary part of the STFT, type: pybind11::array_t<float>
        * @param realInput    A flag indicating whether to use only the real input, type: bool
        * @param normalize    A flag indicating whether to normalize the output, type: bool
        * @param L            The length of the original time-domain signal, type: int
        * @param hop_len      The hop length used during the STFT, type: int
        * @param pad_mode     The padding mode, type: int
        * @param win_mode     The window type used during the STFT, type: int
        * 
        * @return A pybind11::array_t<float> representing the reconstructed time-domain signal.
        */
        std::tuple<pybind11::array_t<float>, pybind11::array_t<float>> Bmcv::istft(
            pybind11::array_t<float> input_real,
            pybind11::array_t<float> input_imag,
            bool realInput,
            bool normalize,
            int L,
            int hop_len,
            int pad_mode,
            int win_mode
        );

        std::tuple<Tensor, Tensor> Bmcv::istft(
            Tensor &input_real,
            Tensor &input_imag,
            bool realInput,
            bool normalize,
            int L,
            int hop_len,
            int pad_mode,
            int win_mode
        );



MultiDecoder
______________

**1). MultiDecoder Constructor**
    .. code-block:: c

        /**
         * @brief Constructor
         * 
         * @param queue_size    Max data queue size.
         * @param tpu_id        ID of Tensor Computing Processor, there may be more than one Tensor Computing Processor for PCIE mode.
         * @param discard_mode  Data discard policy when the queue is full. If 0, do not push the data to queue, else pop the data from queue and push new data to queue.
        */
        explicit MultiDecoder(
            int queue_size=10, 
            int tpu_id=0, 
            int discard_mode=0);


**2). set_read_timeout**
    .. code-block:: c

        /**
         * @brief Set read frame timeout waiting time 
         * 
         * @param time_second Set read frame timeout waiting time in seconds
         */
        void set_read_timeout(int time_second);

**3). add_channel**
    .. code-block:: c

        /**
         * @brief Add a channel to decode
         * 
         * @param file_path         Path or rtsp url to the video/image file.
         * @param frame_skip_num    Frame skip number.
         * @return  return channel index number.
         */
        int add_channel(
            const std::string&  file_path, 
            int                 frame_skip_num=0);

**4). del_channel**
    .. code-block:: c

        /**
         * @brief Delete channel
         * 
         * @param channel_idx Channel index number.
         * @return 0 for success and other for failure. 
         */
        int del_channel(int channel_idx);

**5). clear_queue**
    .. code-block:: c

        /**
         * @brief Clear data cache queue
         * 
         * @param channel_idx Channel index number.
         * @return 0 for success and other for failure  
         */
        int clear_queue(int channel_idx);

**6). read**
    .. code-block:: c

        /**
         * @brief Read a BMImage from the MultiDecoder with a given channel.
         * 
         * @param channel_idx   Channel index number.
         * @param image         Reference of BMImage to be read to   
         * @param read_mode     Read data mode, 0 for not waiting data and other waiting data.
         * @return 0 for successed get data. 
         */
        int read(
            int         channel_idx,
            BMImage&    image,
            int         read_mode=0);

        /**
         * @brief Read a BMImage from the MultiDecoder with a given channel.
         * 
         * @param channel_idx Channel index number.
         * @return BMImage instance to be read to  
         */
        BMImage read(int channel_idx);

**7). read_**
    .. code-block:: c

        /**
         * @brief Read a bm_image from the MultiDecoder with a given channel.
         * 
         * @param channel_idx   Channel index number.
         * @param image         Reference of bm_image to be read to 
         * @param read_mode     Read data mode, 0 for not waiting data and other waiting data.
         * @return 0 for successed get data.  
         */
        int read_(
            int         channel_idx,
            bm_image&   image,
            int         read_mode=0);
        
        /**
         * @brief Read a bm_image from the MultiDecoder with a given channel.
         * 
         * @param channel_idx  Channel index number.
         * @return bm_image instance to be read to.
         */
        bm_image read_(int channel_idx);

**8). reconnect**
    .. code-block:: c

        /**
         * @brief Reconnect Decoder for instance channel.
         * 
         * @param channel_idx Channel index number.
         * @return 0 for success and other for failure. 
         */
        int reconnect(int channel_idx);

**9). get_frame_shape**
    .. code-block:: c

        /**
         * @brief Get frame shape for instance channel
         * 
         * @param channel_idx Channel index number.
         * @return Frame shape, [1, C, H, W]
         */
        std::vector<int> get_frame_shape(int channel_idx);

**10). set_local_flag**
    .. code-block:: c

        /**
         * @brief Set local video flag
         * 
         * @param flag  If flag is True, Decode up to 25 frames per second
         */
        void set_local_flag(bool flag);

**11). get_channel_fps**
    .. code-block:: c

        /**
         * @brief Get the fps of the video stream in a specified channel
         * 
         * @param channel_idx Channel index number.
         * @return Returns the fps of the video stream in the specified channel 
         */
        float get_channel_fps(int channel_idx);

**12). get_drop_num**
    .. code-block:: c

        /**
         * @brief Get drop num for instance channel.
         * 
         * @param channel_idx Channel index number.
         * @return num for instance channel. 
         */
        size_t get_drop_num(int channel_idx);

**12). reset_drop_num**
    .. code-block:: c

        /**
         * @brief Set drop num init 0 for instance channel.
         * 
         * @param channel_idx Channel index number. 
         */
        void reset_drop_num(int channel_idx);

sail_resize_type
__________________

**1). sail_resize_type**
    .. code-block:: c

        enum sail_resize_type {
            BM_RESIZE_VPP_NEAREST = 0,
            BM_RESIZE_TPU_NEAREST = 1,
            BM_RESIZE_TPU_LINEAR = 2,
            BM_RESIZE_TPU_BICUBIC = 3,
            BM_PADDING_VPP_NEAREST = 4,
            BM_PADDING_TPU_NEAREST = 5,
            BM_PADDING_TPU_LINEAR = 6,
            BM_PADDING_TPU_BICUBIC = 7
        };


ImagePreProcess
_________________

**1). ImagePreProcess**
    .. code-block:: c

        /**
         * @brief Constructor
         * 
         * @param batch_size        Output batch size
         * @param resize_mode       Resize Methods 
         * @param tpu_id            ID of Tensor Computing Processor, there may be more than one Tensor Computing Processor for PCIE mode,default is 0.
         * @param queue_in_size     Max input image data queue size, default is 20.
         * @param queue_out_size    Max output tensor data queue size, default is 20.
         * @param use_mat_flag      Use cv Mat for output, default is false.
        */
        explicit ImagePreProcess(
            int batch_size,
            sail_resize_type resize_mode,
            int tpu_id=0, 
            int queue_in_size=20, 
            int queue_out_size=20,
            bool use_mat_flag=false);

**2). ~ImagePreProcess**
    .. code-block:: c

        /**
         * @brief Destructor
         */
        ~ImagePreProcess();

**3). SetResizeImageAtrr**
    .. code-block:: c

        /**
         * @brief Set the Resize Image attribute
         * 
         * @param output_width  The width of resized image.
         * @param output_height The height of resized image.
         * @param bgr2rgb       The flag of convert BGR image to RGB.
         * @param dtype         The data type of resized image,Only supported BM_FLOAT32,BM_INT8,BM_UINT8     
         */
        void SetResizeImageAtrr(			    
            int output_width,				    
            int output_height,				    
            bool bgr2rgb,					    
            bm_image_data_format_ext  dtype);	

**4). SetPaddingAtrr**
    .. code-block:: c

        /**
         * @brief Set the padding attribute object
         * 
         * @param padding_b padding value of b channel, dafault 114
         * @param padding_g padding value of g channel, dafault 114
         * @param padding_r padding value of r channel, dafault 114
         * @param align     padding position, default 0: start left top, 1 for center
         * @return padding position, {start point x,start point y, resize width, resize height}
         */
        void SetPaddingAtrr(		    
            int padding_b=114,		        
            int padding_g=114,		        
            int padding_r=114,		        
            int align=0);		            

**5). SetConvertAtrr**
    .. code-block:: c

        /**
         * @brief Set the linear transformation attribute.
         * 
         * @param alpha_beta (a0, b0), (a1, b1), (a2, b2) factors
         * @return 0 for success and other for failure 
         */
        int SetConvertAtrr(
            const std::tuple<
                std::pair<float, float>,
                std::pair<float, float>,
                std::pair<float, float>> &alpha_beta);

**6). PushImage**
    .. code-block:: c

        /**
         * @brief Push Image
         * 
         * @param channel_idx   Channel index number of the image.
         * @param image_idx     Image index number of the image.
         * @param image         Input image
         * @return 0 for success and other for failure 
         */
        int PushImage(
            int channel_idx, 
            int image_idx, 
            BMImage &image);

**7). GetBatchData**
    .. code-block:: c

        /**
         * @brief Get the Batch Data object
         * 
         * @return std::tuple<sail::Tensor,      Output Tensor map.
         * std::vector<BMImage>,                 Original Images
         * std::vector<int>,                     Original Channel index
         * std::vector<int>>                     Original Index
         * std::vector<std::vector<int>>>        Padding Atrr(start_x, start_y, width, height)
         */
        std::tuple<sail::Tensor, 
            std::vector<BMImage>,
            std::vector<int>,
            std::vector<int>,
            std::vector<std::vector<int>>> GetBatchData();

**8). GetBatchData_CV**
    .. code-block:: c

        /**
         * @brief Get the Batch Data object
         * 
         * @return std::tuple<sail::Tensor,      Output Tensor map.
         * std::vector<cv::Mat>,                 Original Images
         * std::vector<int>,                     Original Channel index
         * std::vector<int>>                     Original Index
         * std::vector<std::vector<int>>>        Padding Atrr(start_x, start_y, width, height)
         */
        std::tuple<sail::Tensor, 
            std::vector<cv::Mat>,
            std::vector<int>,
            std::vector<int>,
            std::vector<std::vector<int>>> GetBatchData_CV();


**9). set_print_flag**
    .. code-block:: c  

        /** @brief Print main process time use.
         *
         *  @param print_flag.
         */  
        void set_print_flag(bool print_flag); 

EngineImagePreProcess 
_______________________

**1). EngineImagePreProcess**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param bmodel_path        Path to bmodel
         * @param tpu_id             ID of Tensor Computing Processor, there may be more than one Tensor Computing Processor for PCIE mode.
         * @param use_mat_output     Use cv::Mat for output.
        */
        EngineImagePreProcess(const std::string& bmodel_path, int tpu_id, bool use_mat_output=false);

**2). ~EngineImagePreProcess**
    .. code-block:: c

        /**
         * @brief Destructor
         */
        ~EngineImagePreProcess();

**3). InitImagePreProcess**
    .. code-block:: c

         /**
         * @brief initialize ImagePreProcess
         * 
         * @param resize_mode       Resize Methods 
         * @param bgr2rgb           The flag of convert BGR image to RGB, default is false
         * @param queue_in_size     Max input image data queue size, default is 20.
         * @param queue_out_size    Max output tensor data queue size, default is 20.
         * @return 0 for success and other for failure 
        */
        int InitImagePreProcess(
            sail_resize_type resize_mode,
            bool bgr2rgb=false,					    
            int queue_in_size=20, 
            int queue_out_size=20);

**4). SetPaddingAtrr**
    .. code-block:: c

        /**
         * @brief Set the padding attribute object
         * 
         * @param padding_b padding value of b channel, dafault 114
         * @param padding_g padding value of g channel, dafault 114
         * @param padding_r padding value of r channel, dafault 114
         * @param align     padding position, default 0: start left top, 1 for center
         * @return 0 for success and other for failure 
         */
        int SetPaddingAtrr(
            int padding_b=114,
            int padding_g=114,	
            int padding_r=114, 
            int align=0);

**4). SetConvertAtrr**
    .. code-block:: c

        /**
         * @brief Set the linear transformation attribute.
         * 
         * @param alpha_beta (a0, b0), (a1, b1), (a2, b2) factors
         * @return 0 for success and other for failure 
         */
        int SetConvertAtrr(
            const std::tuple<
                std::pair<float, float>,
                std::pair<float, float>,
                std::pair<float, float>> &alpha_beta);

**5). PushImage**
    .. code-block:: c

        /**
         * @brief Push Image
         * 
         * @param channel_idx   Channel index number of the image.
         * @param image_idx     Image index number of the image.
         * @param image         Input image
         * @return 0 for success and other for failure 
         */
        int PushImage(
            int channel_idx, 
            int image_idx, 
            BMImage &image);

**6). GetBatchData**
    .. code-block:: c

        /**
         * @brief Get the Batch Data object
         * 
         * @return std::tuple<std::map<std::string,sail::Tensor*>,      Output Tensor map.
         * std::vector<BMImage>,                                        Original Images
         * std::vector<int>,                                            Original Channel index
         * std::vector<int>>                                            Original Index
         * std::vector<std::vector<int>>>                               Padding Atrr(start_x, start_y, width, height)
         */
        std::tuple<std::map<std::string,sail::Tensor*>, 
            std::vector<BMImage>,
            std::vector<int>,
            std::vector<int>,
            std::vector<std::vector<int>>> GetBatchData();

**7). GetBatchData_CV**
    .. code-block:: c

        /**
         * @brief Get the Batch Data object
         * 
         * @return std::tuple<std::map<std::string,sail::Tensor*>,      Output Tensor map.
         * std::vector<cv::Mat>,                                        Original Images
         * std::vector<int>,                                            Original Channel index
         * std::vector<int>>                                            Original Index
         * std::vector<std::vector<int>>>                               Padding Atrr(start_x, start_y, width, height)
         */
        std::tuple<std::map<std::string,sail::Tensor*>, 
            std::vector<cv::Mat>,
            std::vector<int>,
            std::vector<int>,
            std::vector<std::vector<int>>> GetBatchData_CV();


**8). get_graph_name**
    .. code-block:: c

        /**
         * @brief Get first graph name in the loaded bomodel.
         *
         * @return First graph name
         */
        std::string get_graph_name();


**9). get_input_width**
    .. code-block:: c

        /**
         * @brief Get model input width.
         * 
         * @return Model input width
        */
        int get_input_width();

**10). get_input_height**
    .. code-block:: c

        /**
         * @brief Get model input height.
         * 
         * @return Model input height
        */
        int get_input_height();

**11). get_output_names**
    .. code-block:: c

        /**
         * @brief Get all output tensor names of the first graph.
         *
         * @return All the output tensor names of the graph
         */
        std::vector<std::string> get_output_names();

**12). get_output_shape**
    .. code-block:: c

        /**
         * @brief Get the shape of an output tensor in frist graph.
         *
         * @param tensor_name The specified tensor name
         * @return The shape of the tensor
         */
        std::vector<int> get_output_shape(const std::string& tensor_name);

algo_yolov5_post_1output 
____________________________

**1). algo_yolov5_post_1output**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param shape             Input Data shape 
         * @param network_w         Network input width 
         * @param network_h         Network input height 
         * @param max_queue_size    Data queue max size
         * @param input_use_multiclass_nms Multiclass nms
         * @param agnostic          NO-Class-specific nms
         */
        algo_yolov5_post_1output(const std::vector<int>& shape, int network_w=640, int network_h=640, int max_queue_size=20, bool input_use_multiclass_nms=true, bool agnostic=false);

**2). ~algo_yolov5_post_1output**
    .. code-block:: c

        /**
         * @brief Destructor 
         */  

**3). push_data**
    .. code-block:: c

        /**
         * @brief Push Data
         * 
         * @param channel_idx       Channel index number of the image.
         * @param image_idx         Image index number of the image.
         * @param input_data        Input Data ptr
         * @param dete_threshold    Detection threshold
         * @param nms_threshold     NMS threshold
         * @param ost_w             Original image width
         * @param ost_h             Original image height
         * @param padding_attr      Padding Attribute(start_x, start_y, width, height)
         * @return 0 for success and other for failure 
         */
        int push_data(
            std::vector<int> channel_idx, 
            std::vector<int> image_idx, 
            TensorPTRWithName input_data, 
            std::vector<float> dete_threshold,
            std::vector<float> nms_threshold,
            std::vector<int> ost_w,
            std::vector<int> ost_h,
            std::vector<std::vector<int>> padding_attr);
            
algo_yolov5_post_3output 
____________________________

**1). algo_yolov5_post_3output**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param shape             Input Data shape 
         * @param network_w         Network input width 
         * @param network_h         Network input height 
         * @param max_queue_size    Data queue max size
         * @param input_use_multiclass_nms Multiclass nms
         * @param agnostic          NO-Class-specific nms
         */
        algo_yolov5_post_3output(const std::vector<std::vector<int>>& shape, int network_w=640, int network_h=640, int max_queue_size=20, bool input_use_multiclass_nms=true, bool agnostic=false);

**2). ~algo_yolov5_post_3output**
    .. code-block:: c

        /**
         * @brief Destructor 
         */  

**3). reset_anchors**
    .. code-block:: c

        /**
         * @brief Reset Anchor
         * @param anchors          new anchors
         * @return 0 for success and other for failure
         */ 
        int reset_anchors(std::vector<std::vector<std::vector<int>>> anchors_new);

**4). push_data**
    .. code-block:: c

        /**
         * @brief Push Data
         * 
         * @param channel_idx       Channel index number of the image.
         * @param image_idx         Image index number of the image.
         * @param input_data        Input Data
         * @param dete_threshold    Detection threshold
         * @param nms_threshold     NMS threshold
         * @param ost_w             Original image width
         * @param ost_h             Original image height
         * @param padding_attr      Padding Attribute(start_x, start_y, width, height)
         * @return 0 for success and other for failure 
         */
        int push_data(
            std::vector<int> channel_idx, 
            std::vector<int> image_idx, 
            std::vector<sail::Tensor*> input_data, 
            std::vector<float> dete_threshold, 
            std::vector<float> nms_threshold, 
            std::vector<int> ost_w, 
            std::vector<int> ost_h, 
            std::vector<std::vector<int>> padding_attr);


**5). get_result**
    .. code-block:: c

        /**
         * @brief Get Result
         * 
         * @return Detect results, channle index, image index
         */  
         std::tuple<std::vector<DeteObjRect>,int,int> get_result();

algo_yolov5_post_cpu_opt_async 
____________________________

**1). algo_yolov5_post_cpu_opt_async**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param shape             Input Data shape 
         * @param network_w         Network input width 
         * @param network_h         Network input height 
         * @param max_queue_size    Data queue max size
         * @param use_multiclass_nms Whether to use multi-class NMS
         */
        algo_yolov5_post_cpu_opt_async(const std::vector<std::vector<int>>& shape, int network_w=640, int network_h=640, int max_queue_size=20, bool use_multiclass_nms=true);

**2). ~algo_yolov5_post_cpu_opt_async**
    .. code-block:: c

        /**
         * @brief Destructor 
         */  

**3). reset_anchors**
    .. code-block:: c

        /**
         * @brief Reset Anchor
         * @param anchors          new anchors
         * @return 0 for success and other for failure
         */ 
        int reset_anchors(std::vector<std::vector<std::vector<int>>> anchors_new);

**4). push_data**
    .. code-block:: c

        /**
         * @brief Push Data
         * 
         * @param channel_idx       Channel index number of the image.
         * @param image_idx         Image index number of the image.
         * @param input_data        Input Data
         * @param dete_threshold    Detection threshold
         * @param nms_threshold     NMS threshold
         * @param ost_w             Original image width
         * @param ost_h             Original image height
         * @param padding_attr      Padding Attribute(start_x, start_y, width, height)
         * @return 0 for success and other for failure 
         */
        int push_data(
            std::vector<int> channel_idx, 
            std::vector<int> image_idx, 
            std::vector<TensorPTRWithName> input_data, 
            std::vector<float> dete_threshold, 
            std::vector<float> nms_threshold, 
            std::vector<int> ost_w, 
            std::vector<int> ost_h, 
            std::vector<std::vector<int>> padding_attr);


**5). get_result**
    .. code-block:: c

        /**
         * @brief Get Result
         * 
         * @return Detect results, channle index, image index
         */  
         std::tuple<std::vector<DeteObjRect>,int,int> get_result();

algo_yolox_post 
____________________________

**1). algo_yolox_post**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param shape             Input Data shape 
         * @param network_w         Network input width 
         * @param network_h         Network input height 
         * @param max_queue_size    Data queue max size
         */
        algo_yolox_post(const std::vector<int>& shape, int network_w=640, int network_h=640, int max_queue_size=20);

**2). ~algo_yolox_post**
    .. code-block:: c

        /**
         * @brief Destructor 
         */  

**3). push_data**
    .. code-block:: c

        /**
         * @brief Push Data
         * 
         * @param channel_idx       Channel index number of the image.
         * @param image_idx         Image index number of the image.
         * @param input_data        Input Data ptr
         * @param dete_threshold    Detection threshold
         * @param nms_threshold     NMS threshold
         * @param ost_w             Original image width
         * @param ost_h             Original image height
         * @param padding_attr      Padding Attribute(start_x, start_y, width, height)
         * @return 0 for success and other for failure 
         */
        int push_data(
            std::vector<int> channel_idx, 
            std::vector<int> image_idx, 
            TensorPTRWithName input_data, 
            std::vector<float> dete_threshold,
            std::vector<float> nms_threshold,
            std::vector<int> ost_w,
            std::vector<int> ost_h,
            std::vector<std::vector<int>> padding_attr);

**4). get_result**
    .. code-block:: c

        /**
        * @brief Get Result
        * 
        * @return Detect results, channle index, image index
        */
        std::tuple<std::vector<DeteObjRect>,int,int> get_result();

sort_tracker_controller
________________________________

**1). sort_tracker_controller**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         *  
         * @param max_iou_distance Maximum Intersection over Union (IoU) distance threshold used in the tracker
         * @param max_age The maximum number of frames that a tracked object can exist in the tracker 
         * @param n_init The threshold for the number of initialization frames in the tracker 
         */
        sort_tracker_controller(float max_iou_distance = 0.7, int max_age = 30, int n_init = 3);
 
**2). ~sort_tracker_controller**
    .. code-block:: c
 
        /**
         * @brief Destructor 
         */  

**3). process**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features.
         * @param detected_objects Detected objects  
         * @param tracked_objects  Tracked objects   
         * @return 0 for success and other for failure 
         */
        std::vector<std::tuple<int, int, int, int, int, float, int>> process(const std::vector<std::tuple<int, int, int, int ,int, float>>& detected_objects_short);


sort_tracker_controller_async
________________________________

**1). sort_tracker_controller_async**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param max_cosine_distance Maximum threshold for cosine distance used in similarity calculation            
         * @param nn_budget Maximum number for nearest neighbor search        
         * @param k_feature_dim The feature dimension of the detected objects        
         * @param max_iou_distance Maximum Intersection over Union (IoU) distance threshold used in the tracker
         * @param max_age The maximum number of frames that a tracked object can exist in the tracker 
         * @param n_init The threshold for the number of initialization frames in the tracker 
         * @param queue_size Buffer size of the result queue
         */
        sort_tracker_controller_async(float max_cosine_distance, int nn_budget, int k_feature_dim, float max_iou_distance = 0.7, int max_age = 30, int n_init = 3, int queue_size = 10);

**2). push_data**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features.
         * @param detected_objects Detected objects  
         * @return 0 for success and other for failure 
         */
        int push_data(const std::vector<std::tuple<int, int, int, int ,int, float>>& detected_objects_short);

**3). get_result**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features. 
         * @return tracked_objects  Tracked objects   
         */
        std::vector<std::tuple<int, int, int, int, int, float, int>> get_result_npy(); 

deepsort_tracker_controller
________________________________

**1). deepsort_tracker_controller**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param max_cosine_distance Maximum threshold for cosine distance used in similarity calculation            
         * @param nn_budget Maximum number for nearest neighbor search        
         * @param k_feature_dim The feature dimension of the detected objects        
         * @param max_iou_distance Maximum Intersection over Union (IoU) distance threshold used in the tracker
         * @param max_age The maximum number of frames that a tracked object can exist in the tracker 
         * @param n_init The threshold for the number of initialization frames in the tracker 
         */
        deepsort_tracker_controller(float max_cosine_distance, int nn_budget, int k_feature_dim, float max_iou_distance = 0.7, int max_age = 30, int n_init = 3);
 
**2). ~deepsort_tracker_controller**
    .. code-block:: c
 
        /**
         * @brief Destructor 
         */  

**3). process**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features.
         * @param detected_objects Detected objects  
         * @param feature The features of the detected objects    
         * @param tracked_objects  Tracked objects   
         * @return 0 for success and other for failure 
         */
        int process(const vector<DeteObjRect>& detected_objects, vector<Tensor>& feature, vector<TrackObjRect>& tracked_objects);
        int process(const vector<DeteObjRect>& detected_objects, vector<vector<float>>& feature, vector<TrackObjRect>& tracked_objects);

deepsort_tracker_controller_async
________________________________

**1). deepsort_tracker_controller**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param max_cosine_distance Maximum threshold for cosine distance used in similarity calculation            
         * @param nn_budget Maximum number for nearest neighbor search        
         * @param k_feature_dim The feature dimension of the detected objects        
         * @param max_iou_distance Maximum Intersection over Union (IoU) distance threshold used in the tracker
         * @param max_age The maximum number of frames that a tracked object can exist in the tracker 
         * @param n_init The threshold for the number of initialization frames in the tracker 
         * @param queue_size Buffer size of the result queue
         */
        deepsort_tracker_controller(float max_cosine_distance, int nn_budget, int k_feature_dim, float max_iou_distance = 0.7, int max_age = 30, int n_init = 3, int queue_size = 10);

**2). push_data**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features.
         * @param detected_objects Detected objects  
         * @param feature The features of the detected objects    
         * @return 0 for success and other for failure 
         */
        int push_data(const vector<DeteObjRect>& detected_objects, vector<Tensor>& feature);
        int push_data(const vector<DeteObjRect>& detected_objects, vector<vector<float>>& feature);

**3). get_result**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features. 
         * @return tracked_objects  Tracked objects   
         */
        vector<TrackObjRect> get_result();

bytetrack_tracker_controller
_____________________________________

**1). bytetrack_tracker_controller**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param frame_rate Used to control the maximum number of frames allowed to disappear for tracked objects            
         * @param track_buffer Used to control the maximum number of frames allowed to disappear for tracked objects       
         */
        bytetrack_tracker_controller(int frame_rate = 30, int track_buffer = 30);
 
**2). ~bytetrack_tracker_controller**
    .. code-block:: c
 
        /**
         * @brief Destructor 
         */  

**3). process**
    .. code-block:: c
 
        /**
         * @brief Track the objects based on the detected objects and their features.
         * 
         * @param detected_objects Detected objects   
         * @param tracked_objects  Tracked objects   
         * @return 0 for success and other for failure 
         */
        int process(const vector<DeteObjRect>& detected_objects, vector<TrackObjRect>& tracked_objects);

algo_yolov5_post_cpu_opt 
____________________________

**1). algo_yolov5_post_cpu_opt**
    .. code-block:: c  
        
        /**
         * @brief Constructor
         * 
         * @param shape             Input Data shape 
         * @param network_w         Network input width 
         * @param network_h         Network input height 
         */
        algo_yolov5_post_cpu_opt(const std::vector<std::vector<int>>& shape, int network_w=640, int network_h=640);

**2). ~algo_yolov5_post_cpu_opt**
    .. code-block:: c

        /**
         * @brief Destructor 
         */  

**3). process**
    .. code-block:: c

        /**
        * @brief Porcess
        * 
        * @param input_data                    Input Data
        * @param ost_w                         Original image width
        * @param ost_h                         Original image height
        * @param dete_threshold                Detection threshold
        * @param nms_threshold                 NMS threshold
        * @param input_keep_aspect_ratio       Input keeping aspect ratio  
        * @param input_use_multiclass_nms      Input with multiclass
        * @return Detect results [left, top, right, bottom, class_id, score]
        */
        std::vector<std::vector<std::tuple<int, int, int, int ,int, float>>>
            process(std::vector<TensorPTRWithName> &input_data, 
                    std::vector<int> &ost_w,
                    std::vector<int> &ost_h,
                    std::vector<float> &dete_threshold,
                    std::vector<float> &nms_threshold,
                    bool input_keep_aspect_ratio,
                    bool input_use_multiclass_nms);

        std::vector<std::vector<std::tuple<int, int, int, int ,int, float>>>
            process(std::map<std::string, Tensor&>& input_data,
                    std::vector<int> &ost_w,
                    std::vector<int> &ost_h,
                    std::vector<float> &dete_threshold,
                    std::vector<float> &nms_threshold,
                    bool input_keep_aspect_ratio,
                    bool input_use_multiclass_nms);

Encoder 
_______________________

**1). Encoder**
    .. code-block:: c

        /**
         * @brief Constructor for picture encoder
         */
        Encoder();

        /**
         * @brief Constructor for video encoder, support local video file(mp4, ts...) and rtsp/rtmp stream.
         * @param output_path   local video file path and rtsp/rtmp address
         * @param handle        encoder handle instance (either handle instance or device id)
         * @param device_id     encoder device id (either handle instance or device_id, when specify device_id, the encoder will create a Handle internally)
         * @param enc_fmt       encoder format, support h264_bm or h265_bm/hevc_bm
         * @param pix_fmt       encoder pixel format, support NV12 and I420
         * @param enc_params    encoder enc_params, "width=1902:height=1080:gop=32:gop_preset=3:framerate=25:bitrate=2000", width and height are necessary.
         * @param cache_buffer_length The internal cache queue length defaults to 5. sail.Encoder internally maintains a cache queue to improve flow control fault tolerance during pushing stream.
         * @param abort_policy  The reject policy for video_write. 0 for returns -1 immediately. 1 for pop queue header. 2 for clear the queue. 3 for blocking.
         */
        Encoder(const std::string &output_path, Handle &handle, const std::string &enc_fmt, const std::string &pix_fmt, const std::string &enc_params, int cache_buffer_length=5, int abort_policy=0);
        Encoder(const std::string &output_path, int device_id, const std::string &enc_fmt, const std::string &pix_fmt, const std::string &enc_params, int cache_buffer_length=5, int abort_policy=0);
**2). ~Encoder**
    .. code-block:: c

        /**
         * @brief Deconstructor
         */
        ~Encoder();

**3). is_opened**
    .. code-block:: c

        /**
         * @brief get encoder status
         * @return true for opened
         */
        bool is_opened();


**4). pic_encode**
    .. code-block:: c

        /**
         * @brief            encoder picture
         * @param ext        encode format, ".jpg" , ".png" etc.
         * @param image      reference for input bm_image, only support FORMAT_BGR_PACKED, 1N byte
         * @param data       output, encoded data in system memory. 
         * @return data size
         */
         int pic_encode(std::string& ext, bm_image &image, std::vector<u_char>& data);

        /**
         * @brief            encoder picture
         * @param ext        encode format, ".jpg" , ".png" etc.
         * @param image      reference for input BMImage, only support FORMAT_BGR_PACKED, 1N byte
         * @param data       output, encoded data in system memory. 
         * @return data size
         */
         int pic_encode(std::string& ext, BMImage &image, std::vector<u_char>& data);

**5). video_write**
    .. code-block:: c

        /**
         * @brief            Send a frame of image to the video encoder. Asynchronous interface, after format conversion, is placed in the internal cache queue.
         * @param image      On BM1684, it is required that the image shape be consistent with the width and height specified by the encoder, and use bmcv_image_storage_convert to perform format conversion.
                             On BM1684X, use bmcv_image_vpp_convert to resize and format conversion.
         * @return Successfully returned 0, internal cache queue full returned -1. encode failed returns -2. push stream failed returns -3. unknown abort policy returns -4.
         */
         int video_write(bm_image &image);

        /**
         * @brief            Send a frame of image to the video encoder. Asynchronous interface, after format conversion, is placed in the internal cache queue.
         * @param image      On BM1684, it is required that the image shape be consistent with the width and height specified by the encoder, and use bmcv_image_storage_convert to perform format conversion.
                             On BM1684X, use bmcv_image_vpp_convert to resize and format conversion.
         * @return Successfully returned 0, internal cache queue full returned -1. encode failed returns -2. push stream failed returns -3. unknown abort policy returns -4.
         */
         int video_write(BMImage &image);

**6). release**
    .. code-block:: c

        /**
         * @brief   release encoder
         */
         void release();